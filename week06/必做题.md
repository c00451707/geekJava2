6.（必做）基于电商交易场景（用户、商品、订单），设计一套简单的表结构，提交 DDL 的 SQL 文件到 Github（后面 2 周的作业依然要是用到这个表结构）。
CREATE TABLE IF NOT EXISTS `t_user_info`(
   `user_id` varchar(255) COLLATE utf8_bin NOT NULL,
   `user_name` VARCHAR(100) COLLATE utf8_bin NOT NULL,
   `user_password` VARCHAR(100) COLLATE utf8_bin NOT NULL,
   `ID_card` VARCHAR(100) COLLATE utf8_bin NOT NULL,
   `order_id` VARCHAR(100) COLLATE utf8_bin NOT NULL,
   `commodity_id` VARCHAR(100) COLLATE utf8_bin NOT NULL,
   `create_time` datetime DEFAULT NULL COMMENT '创建时间',
   `last_update_time` datetime DEFAULT CURRENT_TIMESTAMP COMMENT '更新时间',
   PRIMARY KEY ( `user_id` )
)ENGINE=InnoDB DEFAULT CHARSET=utf8;


CREATE TABLE IF NOT EXISTS `t_commodity_info`(
   `commodity_id` varchar(255) COLLATE utf8_bin NOT NULL,
   `commodity_name` VARCHAR(100) COLLATE utf8_bin NOT NULL,
   `commodity_desc` VARCHAR(255) COLLATE utf8_bin NOT NULL,
   `commodity_price` VARCHAR(10) COLLATE utf8_bin NOT NULL,
   `commodity_discount` VARCHAR(10) COLLATE utf8_bin NOT NULL,
   `create_time` datetime DEFAULT NULL COMMENT '创建时间',
   `last_update_time` datetime DEFAULT CURRENT_TIMESTAMP COMMENT '更新时间',
   PRIMARY KEY ( `commodity_id` )
)ENGINE=InnoDB DEFAULT CHARSET=utf8;


CREATE TABLE IF NOT EXISTS `t_order_info`(
   `order_id` varchar(255) COLLATE utf8_bin NOT NULL,
   `order_name` VARCHAR(100) COLLATE utf8_bin NOT NULL,
   `order_amount` VARCHAR(10) COLLATE utf8_bin NOT NULL,
   `order_desc` VARCHAR(255) COLLATE utf8_bin NOT NULL,
   `create_time` datetime DEFAULT NULL COMMENT '创建时间',
   `last_update_time` datetime DEFAULT CURRENT_TIMESTAMP COMMENT '更新时间',
   PRIMARY KEY ( `order_id` )
)ENGINE=InnoDB DEFAULT CHARSET=utf8;





数据库设计范式：
什么是关系数据库
数据库设计范式
第一范式（1NF）：关系R 属于第一范式，当且仅当R 中的每一个属性A 的值域只包含原子项
第二范式（2NF）：在满足1NF 的基础上，消除非主属性对码的部分函数依赖（码：指的是主键，主键可以是一个列，也可以是多个列联合起来共同组成）
第三范式（3NF）：在满足2NF 的基础上，消除非主属性对码的传递函数依赖
BC 范式（BCNF）：在满足3NF 的基础上，消除主属性对码的部分和传递函数依赖
第四范式（4NF）：消除非平凡的多值依赖
第五范式（5NF）：消除一些不合适的连接依赖

根据以上范式经验来设计的表可以达到如下效果：
1、数据库表的关系设计的特别清楚明确
2、数据的冗余比较少，重复的数据量比较少，这样的话表就比较好维护。


数据库设计范式
1NF：消除重复数据，即每一列都是不可再分的基本数据项；
每个列都是原子的。
学号           姓名      系名       系主任  课名         分数
10022211101    李小明    经济系     王强    高等数学     98
10022211102    陈小明    经济系     王强    高等数学     99


每个列不能进一步被拆分，就满足第一范式。

学号           姓名      系               课名         分数
10022211101    李小明    经济系-王强      高等数学     98
这样就一定不满足第一范式吗，我认为不一定，如果我这个系统就是没有对 系名与系主任的区分，并且知道系名就一定知道系主任名称，并且系名、系主任一定不会被修改，或者系统根本不care这种关系的变化。



数据库设计范式
2NF：消除部分依赖，表中没有列只与主键的部分相关，即每一行都被主键唯一标识；（一个涉及良好的表，除了主键之外，其他的列都应该与主键相关，并且所有表都要有主键）每个表都有主键。

学号           姓名      系名       系主任  课名         分数
10022211101    李小明    经济系     王强    高等数学     98
10022211102    陈小明    经济系     王强    高等数学     99
10022211103    吴小明    法律系     刘玲    高等数学     89

前5列为联合主键，第6列分数只与学号课名有关系，与其他无关系。它主键中的一部分有关系。
所以进行如下拆分：

学号           课名             分数  （主键：学号、课名）
10022211101    高等数学         98
10022211102    高等数学         99
10022211103    吴小明           89

学号               姓名     系名       系主任  （主键：学号）
10022211101        李小明   经济系     王强
10022211102        陈小明   经济系     王强
10022211103        吴小明   法律系     刘玲 

3NF：消除传递依赖，消除表中列不依赖主键，而是依赖表中的非主键列的情况，即没有列是与主键不相关的。从表只引用主表的主键，即表中每列都和主键相关。


学号               姓名     系名       系主任  （主键：学号）  
10022211101        李小明   经济系     王强
10022211102        陈小明   经济系     王强
10022211103        吴小明   法律系     刘玲 

不满足第三范式，某个姓名的学生的系名，某个系的主任  故这几个列是有依赖传递关系的。


将传递以来的信息拆分出来，放在单独的表里。
学号           课名             分数  （主键：学号、课名）
10022211101    高等数学         98
10022211102    高等数学         99
10022211103    吴小明           89


学号               姓名     系名     （主键：学号）  
10022211101        李小明   经济系  
10022211102        陈小明   经济系  
10022211103        吴小明   法律系  


系名       系主任  （主键：系名）
经济系     王强
法律系     刘玲 


BCNF：Boyce-Codd Normal Form（巴斯-科德范式）
3NF 的基础上消除主属性对于码的部分与传递函数依赖。

仓库名    管理员      物品名        数量  （仓库名，管理员，物品名 主键）
上海仓    张三        iPhone 5S     30
上海仓    张三        iPad Air      40
北京仓    李四        iPhone 5S     50
北京仓    李四        iPad  Min     60

我们会发现，我们想在这张表中添加一个深圳仓，但此时我们还未给她分配管理员，这条记录就插入不进来，因为数据不完整，单独的库也不能换作为主键，这条记录也不再方便维护。

实际业务系统应该是先录入一个仓库、此时还未分配管理员、也没有物品。然后在条件成熟之后我们再会去配管理员，有了管理员、仓库了之后再会去放物品。对仓库的管理员以及物品单独进行维护，此时以上表结构就不合适我们用。

仓库：
仓库名    管理员
上海仓    张三  
北京仓    李四  

库存：

仓库名     物品名        数量
上海仓     iPhone 5S     30
上海仓     iPad Air      40
北京仓     iPhone 5S     50
北京仓     iPad  Min     60



第4、5范式用的比较少了，很多时候引入少量的冗余字段，来提升我们其他的方便性便捷性以及效率是非常必要的。








MySQL 数据库设计优化-最佳实践
- 如何恰当选择引擎？
当我们不需要事物，然后我们数据操作量有比较大，比如：做一些偏向内容的这种CMS的内容管理系统，动态网站的内容渲染，一些论坛之类的，不需要强事物，我们可以用myISAM这样的引擎。

当我们需要强事物做业务系统，如：电商、支付、金融这样一些业务，那么我们的引擎需要使用innodb（现在使用最多也是默认的引擎）。

当我们需要在内存临时建一个表要求它的速度快数量小，同事不需要它持久化，重写丢了没关系，我们重新搞，这时候我们可以使用memory内存。

当我们的数据都是归档的，那么我们可以使用achieve，甚至可以使用toku，toku压缩效率非常高，能够把我们常规的一些文本文件的数据压缩几十分之一，最夸张的压缩到五十甚至以百分之一（把重复的额东西压缩了，用一个索引代替。故当我们存的数据中有大量数据是重复的，那么压缩就特别有效）。

包括我现在常见的Http协议，非常建议大家只要是B/S系统：有web service，前面不管是 比如spring boot，还是Ngiux挂前面，都建议开启它们的glib压一下，常规的一般都能把数据压缩到1/10以下，能够大大的减少我们网络之间的数据的流量。提升我们整个网站加载的速度。
- 库表如何命名？
用前缀来表示不同的模块。如果进一步我们的业务量比较大，我们可以用模块名作为我们数据库的名字，订单库、用户库，在一步表的名字，就用表实际产生作用的名字即可。

- 如何合理拆分宽表？
当表比较宽，有2、3百列时，它的执行效率就非常低，还有其他一些副作用：
利用范式的方式，把它拆分成一个主表多个子表，把每个表的列数降低。

- 如何选择恰当数据类型：明确、尽量小
- char、varchar 的选择
char 占用的空间是我们给定的大小，char(64) 占用空间就是64，定长的。
varchar 是变长的，当我们的数据本身都比较小，而且是变长的，使用varchar比较好。
- （text/blob/clob）的使用问题？
同时我们如果我们存一个文本或者一个临时数据（数据量特别大时），这时候我们救护使用到 text/blob/clob 这几种类型。
一般情况下非常不建议大家使用这几种类型，使用它们以后一般我们的性能会下降几倍甚至一个数量级。一般他比较长，会影响我们每个块能容纳的数据的条数、记录数。会影响总的表的容量，从而影响性能。另一方面： blob、 clob 这两种数据类型，默认情况下，是先把其他记录插入表中，把这个列空出来，然后在单独拿这个列，用update的方式打开一个流，再把这个流输进去，最后在走整个提交。即：正常情况下我们插入一条数据只需要与数据库打一次交道，提交一次。而插入带有 blob/clob 类型的列时，会与数据库交互两次。（clob好一点，可以被当做string来用，blob则不行）

- 文件、图片是否要存入到数据库？
建议大家把 文件、图片 这种，甚至一些大的、特别大的string都直接存成文件，要么存在当前应用服务器的磁盘里，要么存在分布式的文件系统上去。然后在数据库的这个字段里，脂肪上当前文件的路径或者放它在分布式文件系统的一个URL、一个标符。

- 时间日期的存储问题？
date、datetime、timestamp也可以村我们一个long型的时间挫。
对时间要求不严格，使用应用程序的时间戳，如果对时间有严格的一致性要求，使用数据库的时间戳，但是要注意时区的问题。
对于这种情况我们也可以使用一个long型的数字来表示时间戳，这样就避免了时区不同带来的问题，我们直接使用long型数字进行比较。

- 数值的精度问题？
 double  float都是有精度的。long int也有长度的限制。对于此种情况我们可以使用字符串的方式来表示，或者使用科学技术法，用两个字段表示一个数。
 int(3) 与 int(8)在建表时没有任何区别，就是显示的区别。
- 是否使用外键、触发器？
不要使用 外键、触发器。


- 是否可以冗余字段？
可以有冗余字段，当我们发现每次查主表时，子表里的某些（2、3个）字段都会被使用到。此时就可以将这2、3个字段冗余到主表中。

- 自增主键的使用问题？
当数据量不大时，使用自增主键是可以的。当数据量较大时，需要使用分布式的技术时，不能使用自增主键。

