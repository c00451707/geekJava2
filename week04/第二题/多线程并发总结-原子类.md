/*************************************-原子类-start***********************************/
我们通过同步块，显示地加锁，解决我们在并发多线程计数时，导致的计数不准确问题。
以上方法本质上都是 将所有线程执行执行计数相关代码串行化，需要多线程排队执行，这些多线程不是真正的并发执行计数代码。
Java并发包中的原子计数类可以做到：在保证线程安全、数据正确一致的前提下，提升他的性能，使它运算更快，充分利用多线程计数的能力。

无锁技术– Atomic 工具类
无锁技术的底层实现原理（核心三点技术）：
• Unsafe API - CompareAndSwap
• CPU 硬件指令支持- CAS 指令
• Value 的可见性- volatile 关键字

核心实现原理：
1、volatile 保证读写操作都可见（注意不保证原子）。
2、使用CAS 指令，作为乐观锁实现，通过自旋重试保证写入。

防止发生自旋，即写入的场景不能太频繁。

锁与无锁之争
思考一下，到底是有锁好，还是无锁好？
什么情况下有锁好
什么情况下无锁好
乐观锁、悲观锁
数据库事务锁


CAS 本质上没有使用锁。
并发压力跟锁性能的关系：
1、压力非常小，性能本身要求就不高；（用 CAS 或者 加锁 影响不大）
2、性能要求比较高，压力一般的情况下，无锁更快，大部分都一次写入；（CAS比较有利）
3、压力非常大（经常被多个线程修改）时，自旋导致重试过多，资源消耗很大。


LongAdder 对 AtomicLong 的改进（多个线程对Long的不同为进行计数，消除了CAS的竞争场景，消除了多线程竞争资源的热点问题）
思路： 对一个大的任务，一个大的批数据进行拆分分段，分段完以后每段的复杂度降低，最后将他们归并起来。

通过分段思想改进原子类，
大家想想，还有哪些是用这个思想？
多路归并的思想：
- 快排
- G1 GC
- ConcurrentHashMap
还记得我们讲的爬山，做一个大项目，都需要加里程碑，也是分段。

LongAdder 的改进思路：
1、AtomicInteger 和AtomicLong 里的value 是所有
线程竞争读写的热点数据；
2、将单个value 拆分成跟线程一样多的数组Cell[]；
3、每个线程写自己的Cell[i]++，最后对数组求和。


/*************************************-原子类-end***********************************/
